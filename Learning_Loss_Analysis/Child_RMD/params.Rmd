
```{r, echo=FALSE, include=FALSE}
  tmp_envs <- environment()
  try(if(bindingIsLocked("params", env = tmp_envs)) unlockBinding("params", env = tmp_envs))  #  required if params is sent in through YAML

  ###
	###   Establish directories and paths
	###

  ###   Working Directory
  if (is.null(params$working.directory)) {
    if (!is.null(knitr::opts_knit$get("output.dir"))) {
      params$working.directory <- knitr::opts_knit$get("output.dir")
    } else params$working.directory <- getwd()
  }

  ##  Create assets and/or Rplots directories if doesn't exist
  if (!dir.exists(file.path(params$base.directory, "assets", "Rplots"))) {
    dir.create(file.path(params$base.directory, "assets", "Rplots"), showWarnings = FALSE, recursive = TRUE)
  }
  params$asset.directory <- ifelse(tolower(params$render.format)=="bookdown", file.path(".", "assets"), file.path("..", "assets"))

  tmp.leader <- getPath(params$base.directory, "..") # getPath gets one directory above base.directory here.  
  if (is.null(params$gof.path)) {
    params$gof.path <- file.path(tmp.leader, "Goodness_of_Fit")
  }

  github.download.tf <- ifelse(is.null(params$unvrsl.rmd.path), TRUE,
                          ifelse((tolower(params$unvrsl.rmd.path[[1]]) == "github"), TRUE, FALSE))
  if (github.download.tf) {
    getGithubFile(github.user = "CenterForAssessment", repo = "Universal_Content",
                  github.directory = "Learning_Loss_Analysis/Child_RMD",
                  local.directory = file.path("assets", "rmd", "github_children"), file.type = ".Rmd$")
    params$unvrsl.rmd.path <- file.path("assets", "rmd", "github_children")
  }

  # if (ifelse(!exists("github.download.tf"), FALSE, github.download.tf)) {
  if (github.download.tf) {

    ###  Integrate this into the rendering of the documents not that renderMultiDocument() not used?
    ###  Needs to be at the end of the knitting process, or it will get lost in the `knitr` output...

    # options("renderMultiDocument_Message" = paste0(
    #             "\tChild .Rmd files have been downloaded from Github and 'unvrsl.rmd.path' parameter temporarily set to '", file.path(".", "assets", "rmd", "github_children"), "'!!!\n\t",
    #             "These files may be inspected and edited as needed before re-rendering. In order to keep files for future use/re-rendering, set    \n\t",
    #             "'unvrsl.rmd.path' to '", file.path(".", "assets", "rmd", "github_children"), "' in 'report_params' list or 'params' YAML to avoid file re-download/overwrite.     "))

    ###  From renderMultiDocument() :
    # if (!is.null(getOption("renderMultiDocument_Message"))) message(cat("\033[0;43m", getOption("renderMultiDocument_Message", "\033[0m\n")))
  }

  ###
	###   Lists of state specific variables included in the report.
	###

  ###   Draft
  # Example draft.text <- "FOR INTERNAL USE ONLY - DO NOT CIRCULATE!"
  if (is.null(params$draft.text)) {
    params$draft.text <- ""
  }
  if (params$draft.text != "") {
    if (!grepl("[\\]|[<]", params$draft.text)) {
      params$draft.text <- paste0("<p style='text-align: center;'><br><strong>", params$draft.text, "</strong><br></p>")
    }
  }

  ###   Keyword (i.e. "Learning Loss" or equivalent substitute)
  if (is.null(params$keyword)) {
    params$keyword <- "learning loss"
  }
  if (is.null(params$keyword_camel)) {
    params$keyword_camel <- capwords(params$keyword)
  }

  ###   State name and education organization
  if (toupper(params$state.name)=="DEMONSTRATION COVID") {
    params$state.abv <- "DEMO_COVID"
  }
  if (is.null(params$state.abv)) {
    if (is.null(params$state.name)) stop("State name or abbreviation parameter (state.name or state.abv) must be provided at a minimum!")
    tmp.state.abv <- params$state.abv <- datasets::state.abb[datasets::state.name == params$state.name] # SGP::getStateAbbreviation(params$state.name, type="Abbreviation") # Doesn't work in all cases...
  } else tmp.state.abv <- params$state.abv[[1]]
  if (is.null(params$state.name)) {
    if (is.null(params$state.abv)) stop("State name or abbreviation parameter (state.name or state.abv) must be provided at a minimum!")
    tmp.state.name <- params$state.name <- SGP::getStateAbbreviation(tmp.state.abv, type="state")
  } else tmp.state.name <- params$state.name[[1]]

  if (is.null(params$state.org)) {
    params$state.org <- SGPstateData[[tmp.state.abv]][["Assessment_Program_Information"]][["Organization"]][["Name"]]
  }
  if (is.null(params$state.org.abv)) {
    params$state.org.abv <- SGPstateData[[tmp.state.abv]][["Assessment_Program_Information"]][["Organization"]][["Abbreviation"]]
  }

  if (is.null(params$test.name)) {
    params$test.name <- SGPstateData[[tmp.state.abv]][["Assessment_Program_Information"]][["Assessment_Name"]]
  }
  if (is.null(params$test.abv)) {
    params$test.abv <- SGPstateData[[tmp.state.abv]][["Assessment_Program_Information"]][["Assessment_Abbreviation"]]
  }
  if (is.null(params$test.url)) {
    params$test.url <- SGPstateData[[tmp.state.abv]][["Assessment_Program_Information"]][["Organization"]][["URL"]]
  }
  if (is.null(params$test.trans.year)) {
    params$test.trans.year <- SGPstateData[[tmp.state.abv]][["Assessment_Program_Information"]][["Assessment_Transition"]][["Year"]]
    if (!is.null(params$test.trans.year)) {
      if (grepl("2019", params$test.trans.year)) {
        params$test.trans.name <- SGPstateData[[tmp.state.abv]][["Assessment_Program_Information"]][["Assessment_Transition"]][["Assessment_Abbreviation"]]
      } else params$test.trans.year <- NULL
    }
  }

  ###   SGP version to use (SIMEX, BASELINE, UNCORRECTED, etc.)
  if (is.null(params$baseline.sgp)) {
    params$baseline.sgp <- "SGP_BASELINE"
  }
  if (is.null(params$cohort.sgp)) {
    params$cohort.sgp <- "SGP"
  }

  if (is.null(params$sgp.max.order)) {
    params$sgp.max.order <-
      max(sapply(strsplit(unique(Report_Data[, as.character(SGP_NORM_GROUP)]), ";"), length))-1
  }

  ###   Year Format
  if (is.null(params$Year_Long_Form)) {
    params$Year_Long_Form <- any(grepl("_", unique(Report_Data[, YEAR])))
  }

  ###   Content areas
  if (is.null(params$GL_subjects)) {
    params$GL_subjects <- unique(Report_Data[!is.na(SGP) & GRADE != "EOCT", CONTENT_AREA])
  }
  if (is.null(params$GL_camel)) {
    params$GL_camel <- sapply(params$GL_subjects, capwords) # sub("ela", "ELA", tolower(params$GL_subjects))
  }
  params$GL_text <- paste(paste(head(params$GL_camel, -1), collapse=", "), tail(params$GL_camel, 1), sep=" and ") # sub("ela", "ELA", tolower(params$GL_text))
  params$GL_text_long <- sub("ELA", "English language arts (ELA)", params$GL_text) # "English language arts (ELA) and mathematics"

  if (is.null(params$GoF_GL_subjects)) {
    params$GoF_GL_subjects <- params$GL_subjects
  }

  # if (is.null(params$EOC_subjects)) {
  #   params$EOC_subjects <- unique(Report_Data[!is.na(SGP) & GRADE == "EOCT", CONTENT_AREA])
  # }
  # if (length(params$EOC_subjects > 0)) {
  #   params$eoct.tf <- FALSE
  #   params$EOC_subjects <- NULL
  # } else  params$eoct.tf <- TRUE

  if (is.null(params$EOC_subjects)) {
    params$subject_order <- params$GL_subjects
  } else params$subject_order <- c(params$GL_subjects, params$EOC_subjects)

  if (is.null(params$GoF_EOC_subjects)) {
    params$GoF_EOC_subjects <- params$EOC_subjects
  }

  ###   Grades
  if (is.null(params$grades)) {
    params$grades <- unique(Report_Data[!is.na(SGP_BASELINE), GRADE])
  }
  Grade_x_Subj <- unique(Report_Data[!is.na(SGP_BASELINE) & GRADE != "EOCT", GRADE, CONTENT_AREA])
  Grade_x_Subj_Count <- Grade_x_Subj[, .(Count = length(unique(GRADE))), by = CONTENT_AREA]
  if (!all(diff(Grade_x_Subj_Count$Count)==0)) {
    params$grades.list <- list()
    for (ca in params$subject_order){
      params$grades.list[[ca]] <- Grade_x_Subj[CONTENT_AREA == ca, GRADE]
    }  
    ###  Grade/Subject Subset Restriction :: e.g. ((CONTENT_AREA %in% c('ELA', 'MATHEMATICS') & GRADE %in% 4:10)|(CONTENT_AREA == 'SCIENCE' & GRADE %in% 5:10))
    grd.sub <- sapply(params$grades.list, as.numeric)
    tmp.subset <- "("
    while(length(grd.sub) > 0) {
      common.grds <- names(grd.sub[duplicated(grd.sub)])
      if (length(common.grds) > 0) {
        tmp.subset <- paste0(tmp.subset, "(CONTENT_AREA %in% c('", paste(names(grd.sub)[1], common.grds, sep="', '"), "') & GRADE %in% ", paste0(range(grd.sub[[1]]), collapse=":"), ")")
      } else tmp.subset <- paste0(tmp.subset, "(CONTENT_AREA == '", names(grd.sub)[1], "') & GRADE %in% ", paste0(range(grd.sub[[1]]), collapse=":"), ")")
      grd.sub <- grd.sub[!duplicated(grd.sub)][-1]
      if (length(grd.sub) > 0) tmp.subset <- paste0(tmp.subset, "|")
    }
    params$grd.subset <- tmp.subset
  } else {
    params$grd.subset <- paste0("GRADE %in% c('", paste(params$grades, collapse="','"), "')")
  }

  ###   Minimum School Size
  if (is.null(params$min.school.size)) {
    params$min.school.size <- 10
  }

  if (is.null(params$code.url)) {
    params$code.url <- paste0("https://github.com/CenterForAssessment/", gsub(" ", "_", params$state.name))
  }
  save(params, file=file.path(params$base.directory, paste0("params", params$render.format, ".rda")))
```
